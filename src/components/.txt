import React, { useEffect, useRef, useState, useCallback } from "react";

const CARD_COUNT = 20;
const COLLISION_THRESHOLD = 35; // Distancia mínima entre cartas mejorada
const GRAVITY = 0.8; // Simulación de gravedad
const AIR_RESISTANCE = 0.98; // Resistencia del aire

export default function UltraRealisticRiffleShuffle() {
  const containerRef = useRef();
  const [isAnimating, setIsAnimating] = useState(false);
  const [currentPhase, setCurrentPhase] = useState("Preparando...");
  const [particlesRef, setParticlesRef] = useState([]);
  const [cardPositions, setCardPositions] = useState(new Map());
  const [soundEffects, setSoundEffects] = useState([]);
  const [cameraShake, setCameraShake] = useState(0);
  const cards = Array.from({ length: CARD_COUNT }, (_, i) => i);

  // Sistema de detección de colisiones ultra-mejorado
  const checkCollision = useCallback((pos1, pos2, radius1 = COLLISION_THRESHOLD, radius2 = COLLISION_THRESHOLD) => {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    const dz = (pos1.z || 0) - (pos2.z || 0);
    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz * 0.1); // Z tiene menos peso
    return distance < (radius1 + radius2) / 2;
  }, []);

  // Función avanzada para encontrar posición libre con física
  const findSafePosition = useCallback((targetX, targetY, targetZ = 0, existingPositions, cardId, velocity = { x: 0, y: 0 }) => {
    let safeX = targetX;
    let safeY = targetY;
    let safeZ = targetZ;
    let attempts = 0;
    const maxAttempts = 100;

    while (attempts < maxAttempts) {
      let hasCollision = false;
      
      for (const [id, pos] of existingPositions) {
        if (id !== cardId && checkCollision({ x: safeX, y: safeY, z: safeZ }, pos)) {
          hasCollision = true;
          break;
        }
      }

      if (!hasCollision) {
        return { x: safeX, y: safeY, z: safeZ };
      }

      // Ajustar posición con física mejorada
      const angle = Math.random() * Math.PI * 2;
      const force = COLLISION_THRESHOLD + Math.random() * 30;
      const verticalForce = Math.random() * 20 - 10;
      
      safeX = targetX + Math.cos(angle) * force + velocity.x * 0.5;
      safeY = targetY + Math.sin(angle) * force + velocity.y * 0.5 + verticalForce;
      safeZ = targetZ + Math.random() * 10;
      attempts++;
    }

    return { x: safeX, y: safeY, z: safeZ };
  }, [checkCollision]);

  // Generar partículas dinámicas mejoradas
  const generateParticles = useCallback(() => {
    const particles = [];
    for (let i = 0; i < 50; i++) {
      particles.push({
        id: i,
        x: Math.random() * 1000,
        y: Math.random() * 700,
        z: Math.random() * 100,
        size: Math.random() * 3 + 1,
        opacity: Math.random() * 0.6 + 0.2,
        speed: Math.random() * 4 + 2,
        delay: Math.random() * 2000,
        direction: Math.random() * Math.PI * 2,
        velocity: {
          x: (Math.random() - 0.5) * 2,
          y: (Math.random() - 0.5) * 2,
          z: (Math.random() - 0.5) * 1
        },
        color: ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'][Math.floor(Math.random() * 5)],
        life: 1.0,
        decay: Math.random() * 0.02 + 0.005
      });
    }
    setParticlesRef(particles);
  }, []);

  // Simular efectos de sonido visuales
  const addSoundEffect = useCallback((type, intensity = 1) => {
    const effect = {
      id: Date.now() + Math.random(),
      type,
      intensity,
      timestamp: Date.now()
    };
    setSoundEffects(prev => [...prev.slice(-5), effect]);
    
    // Efecto de vibración de cámara
    if (type === 'riffle' || type === 'bridge') {
      setCameraShake(intensity * 5);
      setTimeout(() => setCameraShake(0), 200);
    }
  }, []);

  // Actualizar partículas con física
  const updateParticles = useCallback(() => {
    setParticlesRef(prev => prev.map(particle => ({
      ...particle,
      x: particle.x + particle.velocity.x,
      y: particle.y + particle.velocity.y,
      z: particle.z + particle.velocity.z,
      velocity: {
        x: particle.velocity.x * AIR_RESISTANCE,
        y: particle.velocity.y * AIR_RESISTANCE + GRAVITY * 0.1,
        z: particle.velocity.z * AIR_RESISTANCE
      },
      life: Math.max(0, particle.life - particle.decay),
      opacity: particle.opacity * particle.life
    })).filter(p => p.life > 0));
  }, []);

  // Animación ultra-realista mejorada
  const ultraRealisticRiffleShuffle = useCallback(() => {
    if (isAnimating) return;
    setIsAnimating(true);
    generateParticles();
    addSoundEffect('shuffle_start', 0.8);

    const allCards = Array.from(containerRef.current.children);
    const middle = Math.floor(allCards.length / 2);
    const leftHalf = allCards.slice(0, middle);
    const rightHalf = allCards.slice(middle);
    const positions = new Map();

    // Resetear con posicionamiento ultra-seguro
    allCards.forEach((card, i) => {
      const baseY = -i * 1.2;
      const baseZ = i * 2;
      const safePos = findSafePosition(0, baseY, baseZ, positions, i);
      positions.set(i, safePos);
      
      card.style.transform = `translateX(${safePos.x}px) translateY(${safePos.y}px) translateZ(${safePos.z}px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(1)`;
      card.style.zIndex = CARD_COUNT - i;
      card.style.transition = 'none';
      card.style.filter = 'brightness(1) saturate(1) blur(0px) drop-shadow(0 2px 8px rgba(0,0,0,0.3))';
    });

    setCardPositions(positions);

    setTimeout(() => {
      setCurrentPhase("Separando con precisión...");
      addSoundEffect('split', 1.2);
      const newPositions = new Map();
      
      // Fase 1: División ultra-realista con física avanzada
      leftHalf.forEach((card, i) => {
        const targetX = -280 - i * 15;
        const targetY = -50 - i * 8;
        const targetZ = i * 12;
        const velocity = { x: -2, y: -0.5 };
        const safePos = findSafePosition(targetX, targetY, targetZ, newPositions, i, velocity);
        newPositions.set(i, safePos);
        
        setTimeout(() => {
          card.style.transition = 'transform 2.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 2.8s ease-out';
          card.style.transform = `translateX(${safePos.x}px) translateY(${safePos.y}px) translateZ(${safePos.z}px) rotateX(${18 + i * 3}deg) rotateY(${-30 + i * 2.5}deg) rotateZ(${-40 + i * 3.5}deg) scale(${1.04 + i * 0.02})`;
          card.style.zIndex = 400 + i;
          card.style.filter = `brightness(${1.25 + i * 0.03}) saturate(1.5) drop-shadow(0 ${15 + i * 4}px ${25 + i * 4}px rgba(0,0,0,0.6)) drop-shadow(0 0 ${10 + i * 2}px rgba(255,215,0,0.3))`;
        }, i * 50);
      });

      rightHalf.forEach((card, i) => {
        const targetX = 280 + i * 15;
        const targetY = -50 - i * 8;
        const targetZ = i * 12;
        const velocity = { x: 2, y: -0.5 };
        const safePos = findSafePosition(targetX, targetY, targetZ, newPositions, middle + i, velocity);
        newPositions.set(middle + i, safePos);
        
        setTimeout(() => {
          card.style.transition = 'transform 2.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 2.8s ease-out';
          card.style.transform = `translateX(${safePos.x}px) translateY(${safePos.y}px) translateZ(${safePos.z}px) rotateX(${18 + i * 3}deg) rotateY(${30 - i * 2.5}deg) rotateZ(${40 - i * 3.5}deg) scale(${1.04 + i * 0.02})`;
          card.style.zIndex = 400 + i;
          card.style.filter = `brightness(${1.25 + i * 0.03}) saturate(1.5) drop-shadow(0 ${15 + i * 4}px ${25 + i * 4}px rgba(0,0,0,0.6)) drop-shadow(0 0 ${10 + i * 2}px rgba(255,215,0,0.3))`;
        }, i * 50);
      });

      setCardPositions(newPositions);

      setTimeout(() => {
        setCurrentPhase("Formando el puente perfecto...");
        addSoundEffect('bridge', 1.5);
        const arcPositions = new Map();
        
        // Fase 2: Arco ultra-cinematográfico con física de puente
        leftHalf.forEach((card, i) => {
          const targetX = -120 - i * 10;
          const arcHeight = 180 + i * 25;
          const targetY = -arcHeight - Math.sin(i * 0.4) * 15;
          const targetZ = i * 15 + Math.sin(i * 0.3) * 8;
          const safePos = findSafePosition(targetX, targetY, targetZ, arcPositions, i);
          arcPositions.set(i, safePos);
          
          setTimeout(() => {
            card.style.transition = 'transform 3.2s cubic-bezier(0.68, -0.55, 0.265, 1.55), filter 3.2s ease-out';
            card.style.transform = `translateX(${safePos.x}px) translateY(${safePos.y}px) translateZ(${safePos.z}px) rotateX(${60 + i * 5}deg) rotateY(${-30 + i * 2.5}deg) rotateZ(${-45 + i * 3}deg) scale(${1.08 + i * 0.025})`;
            card.style.zIndex = 500 + i;
            card.style.filter = `brightness(${1.4 + i * 0.03}) saturate(1.6) drop-shadow(0 ${20 + i * 5}px ${35 + i * 5}px rgba(255,215,0,0.6)) drop-shadow(0 0 ${25 + i * 4}px rgba(255,255,255,0.5)) drop-shadow(0 0 ${15 + i * 2}px rgba(0,150,255,0.3))`;
          }, i * 80);
        });

        rightHalf.forEach((card, i) => {
          const targetX = 120 + i * 10;
          const arcHeight = 180 + i * 25;
          const targetY = -arcHeight - Math.sin(i * 0.4) * 15;
          const targetZ = i * 15 + Math.sin(i * 0.3) * 8;
          const safePos = findSafePosition(targetX, targetY, targetZ, arcPositions, middle + i);
          arcPositions.set(middle + i, safePos);
          
          setTimeout(() => {
            card.style.transition = 'transform 3.2s cubic-bezier(0.68, -0.55, 0.265, 1.55), filter 3.2s ease-out';
            card.style.transform = `translateX(${safePos.x}px) translateY(${safePos.y}px) translateZ(${safePos.z}px) rotateX(${60 + i * 5}deg) rotateY(${30 - i * 2.5}deg) rotateZ(${45 - i * 3}deg) scale(${1.08 + i * 0.025})`;
            card.style.zIndex = 500 + i;
            card.style.filter = `brightness(${1.4 + i * 0.03}) saturate(1.6) drop-shadow(0 ${20 + i * 5}px ${35 + i * 5}px rgba(255,215,0,0.6)) drop-shadow(0 0 ${25 + i * 4}px rgba(255,255,255,0.5)) drop-shadow(0 0 ${15 + i * 2}px rgba(0,150,255,0.3))`;
          }, i * 80);
        });

        setTimeout(() => {
          setCurrentPhase("Riffle mágico ultra-realista...");
          addSoundEffect('riffle', 2.0);
          
          // Fase 3: Riffle con física cuántica
          const shuffledOrder = [];
          const rifflePosistions = new Map();
          
          // Patrón de caída ultra-realista con física avanzada
          let leftIndex = 0, rightIndex = 0;
          while (leftIndex < leftHalf.length || rightIndex < rightHalf.length) {
            const dropLeft = Math.random() > 0.48;
            const burstSize = Math.floor(Math.random() * 3) + 1;
            
            for (let burst = 0; burst < burstSize; burst++) {
              if (dropLeft && leftIndex < leftHalf.length) {
                shuffledOrder.push({ 
                  card: leftHalf[leftIndex], 
                  side: 'left', 
                  index: leftIndex, 
                  burst,
                  velocity: { x: Math.random() * 2 - 1, y: Math.random() * 3 + 2 }
                });
                leftIndex++;
              } else if (rightIndex < rightHalf.length) {
                shuffledOrder.push({ 
                  card: rightHalf[rightIndex], 
                  side: 'right', 
                  index: rightIndex, 
                  burst,
                  velocity: { x: Math.random() * 2 - 1, y: Math.random() * 3 + 2 }
                });
                rightIndex++;
              }
            }
          }

          shuffledOrder.forEach((item, i) => {
            setTimeout(() => {
              const { card, side, burst = 0, velocity } = item;
              
              // Calcular posición con física ultra-avanzada
              const baseX = (i - shuffledOrder.length / 2) * 10;
              const baseY = 100 + Math.sin(i * 0.5) * 25 + burst * 15;
              const baseZ = i * 6 + Math.random() * 10;
              const safePos = findSafePosition(baseX, baseY, baseZ, rifflePosistions, i, velocity);
              rifflePosistions.set(i, safePos);
              
              card.style.transition = 'transform 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 1.2s ease-out';
              
              // Movimiento ultra-realista con múltiples fuerzas
              const wobbleX = Math.sin(i * 0.7) * 10 + velocity.x * 3;
              const wobbleY = Math.cos(i * 0.6) * 8 + velocity.y * 2;
              const spiral = Math.sin(i * 0.2) * 4;
              const turbulence = Math.random() * 6 - 3;

              card.style.transform = `translateX(${safePos.x + wobbleX + turbulence}px) translateY(${safePos.y + wobbleY}px) translateZ(${safePos.z + spiral}px) rotateX(${35 + wobbleX * 0.8}deg) rotateY(${side === 'left' ? -12 + spiral : 12 - spiral}deg) rotateZ(${wobbleX * 1.2 + spiral + turbulence * 0.5}deg) scale(${1.04 + Math.sin(i * 0.25) * 0.04})`;
              card.style.zIndex = 600 + i;
              card.style.filter = `brightness(${1.3 + Math.sin(i * 0.35) * 0.2}) saturate(1.5) drop-shadow(0 ${12 + Math.abs(wobbleX)}px ${22 + Math.abs(wobbleY)}px rgba(0,100,255,0.5)) blur(${Math.abs(wobbleX) * 0.08}px) drop-shadow(0 0 ${8 + i}px rgba(255,255,255,0.4))`;
              
              // Efecto de partículas en cada carta
              if (i % 3 === 0) {
                addSoundEffect('card_flip', 0.6);
              }
            }, i * 100 + Math.random() * 60 + (item.burst || 0) * 30);
          });

          setTimeout(() => {
            setCurrentPhase("Colapso gravitacional...");
            addSoundEffect('collapse', 1.8);
            
            // Fase 4: Colapso con ondas gravitacionales
            shuffledOrder.forEach((item, i) => {
              const { card } = item;
              setTimeout(() => {
                card.style.transition = 'transform 1.8s cubic-bezier(0.23, 1, 0.32, 1), filter 1.8s ease-out';
                const waveX = Math.sin(i * 0.5) * 25;
                const waveY = Math.cos(i * 0.4) * 18;
                const waveZ = Math.sin(i * 0.3) * 8;
                const collapseX = i * 5 + waveX;
                const collapseY = 40 - (i * 1.5) + waveY;
                const collapseZ = i * 3 + waveZ;
                const tiltWave = Math.sin(i * 0.3) * 18;
                
                card.style.transform = `translateX(${collapseX}px) translateY(${collapseY}px) translateZ(${collapseZ}px) rotateX(${tiltWave}deg) rotateY(${Math.sin(i * 0.5) * 6}deg) rotateZ(${Math.sin(i * 0.6) * 10}deg) scale(${1.02 + Math.sin(i * 0.25) * 0.04})`;
                card.style.zIndex = 500 + i;
                card.style.filter = `brightness(${1.2 + Math.sin(i * 0.4) * 0.18}) saturate(1.3) drop-shadow(0 ${8 + Math.abs(waveX) * 0.4}px ${16 + Math.abs(waveY) * 0.6}px rgba(50,205,50,0.4)) drop-shadow(0 0 ${12 + i}px rgba(255,215,0,0.3))`;
              }, i * 60 + Math.sin(i * 0.4) * 40);
            });

            setTimeout(() => {
              setCurrentPhase("Compresión cuántica...");
              addSoundEffect('compress', 1.4);
              
              // Fase 5: Presión con efectos cuánticos
              shuffledOrder.forEach((item, i) => {
                const { card } = item;
                card.style.transition = 'transform 2.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 2.4s ease-out';
                const pressX = i * 4 + Math.sin(i * 0.15) * 6;
                const pressY = -i * 1.5 + Math.cos(i * 0.2) * 4;
                const pressZ = i * 2 + Math.sin(i * 0.1) * 3;
                const quantumFluctuation = Math.sin(i * 0.8) * 2;
                
                card.style.transform = `translateX(${pressX + quantumFluctuation}px) translateY(${pressY}px) translateZ(${pressZ}px) rotateX(${i * 1 + Math.sin(i * 0.25) * 3}deg) rotateY(${Math.sin(i * 0.15) * 3}deg) rotateZ(${i * 0.6 + Math.cos(i * 0.4) * 2}deg) scale(${1.01 + Math.sin(i * 0.12) * 0.025})`;
                card.style.zIndex = 600 + i;
                card.style.filter = `brightness(${1.15 + Math.sin(i * 0.25) * 0.12}) saturate(1.2) drop-shadow(0 ${6 + i * 0.6}px ${12 + i * 1.2}px rgba(0,0,0,0.25)) drop-shadow(0 0 ${8 + i * 0.5}px rgba(255,255,255,0.2))`;
              });

              setTimeout(() => {
                setCurrentPhase("Alineación perfecta final...");
                addSoundEffect('final_align', 1.0);
                
                // Fase 6: Alineación perfecta con efectos holográficos
                shuffledOrder.forEach((item, i) => {
                  const { card } = item;
                  card.style.transition = 'transform 3s cubic-bezier(0.25, 0.46, 0.45, 0.94), filter 3s ease-out';
                  const finalX = i * 0.8 + Math.sin(i * 0.05) * 1;
                  const finalY = -i * 0.6 + Math.cos(i * 0.08) * 0.5;
                  const finalZ = i * 0.8;
                  
                  card.style.transform = `translateX(${finalX}px) translateY(${finalY}px) translateZ(${finalZ}px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(1)`;
                  card.style.zIndex = i;
                  card.style.filter = 'brightness(1) saturate(1) drop-shadow(0 3px 6px rgba(0,0,0,0.15)) drop-shadow(0 0 12px rgba(255,215,0,0.1))';
                });

                setTimeout(() => {
                  setCurrentPhase("¡Shuffle Ultra-Realista Completado!");
                  addSoundEffect('complete', 2.0);
                  setTimeout(() => {
                    setIsAnimating(false);
                    setCurrentPhase("Listo para el próximo shuffle épico");
                  }, 1500);
                }, 3000);
              }, 2400);
            }, shuffledOrder.length * 60 + 500);
          }, shuffledOrder.length * 100 + 1000);
        }, 3200);
      }, 2800);
    }, 400);
  }, [isAnimating, findSafePosition, generateParticles, addSoundEffect]);

  // Actualizar partículas continuamente
  useEffect(() => {
    const interval = setInterval(updateParticles, 50);
    return () => clearInterval(interval);
  }, [updateParticles]);

  useEffect(() => {
    ultraRealisticRiffleShuffle();
  }, [ultraRealisticRiffleShuffle]);

  return (
    <div 
      className="relative flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-gray-900 via-green-900 to-black overflow-hidden"
      style={{
        transform: `translate(${Math.sin(cameraShake * 0.1) * cameraShake}px, ${Math.cos(cameraShake * 0.1) * cameraShake}px)`,
        transition: 'transform 0.1s ease-out'
      }}
    >
      {/* Partículas ultra-dinámicas */}
      {particlesRef.map((particle) => (
        <div
          key={particle.id}
          className="absolute rounded-full animate-pulse pointer-events-none"
          style={{
            left: particle.x,
            top: particle.y,
            width: particle.size,
            height: particle.size,
            backgroundColor: particle.color,
            opacity: particle.opacity,
            transform: `translateZ(${particle.z}px) scale(${particle.life})`,
            boxShadow: `0 0 ${particle.size * 2}px ${particle.color}`,
            animationDelay: `${particle.delay}ms`,
            animationDuration: `${particle.speed}s`
          }}
        />
      ))}

      {/* Efectos de sonido visuales */}
      {soundEffects.map((effect) => (
        <div
          key={effect.id}
          className="absolute inset-0 pointer-events-none"
          style={{
            background: effect.type === 'riffle' 
              ? `radial-gradient(circle, rgba(255,215,0,${effect.intensity * 0.1}) 0%, transparent 70%)`
              : effect.type === 'bridge'
              ? `radial-gradient(ellipse, rgba(0,150,255,${effect.intensity * 0.08}) 0%, transparent 60%)`
              : `radial-gradient(circle, rgba(255,255,255,${effect.intensity * 0.05}) 0%, transparent 50%)`,
            animation: `pulse 0.3s ease-out`
          }}
        />
      ))}

      {/* Efectos de luz ambiental ultra-mejorados */}
      <div className="absolute inset-0 bg-gradient-radial from-yellow-400/15 via-transparent to-transparent animate-pulse"></div>
      <div className="absolute inset-0 bg-gradient-conic from-blue-400/8 via-green-400/8 to-purple-400/8 animate-spin" style={{animationDuration: '25s'}}></div>
      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent animate-shimmer"></div>

      {/* Título ultra-cinematográfico */}
      <div className="mb-8 text-center relative z-10">
        <h1 className="text-9xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-yellow-200 to-yellow-400 mb-4 font-serif tracking-wider drop-shadow-2xl animate-pulse">
          Ultra Riffle Shuffle
        </h1>
        <div className="text-3xl text-green-300 font-light tracking-wide mb-4">
          ✨ Experiencia Hiper-Realista ✨
        </div>
        <div className="text-xl text-yellow-300 font-medium bg-black/40 px-8 py-3 rounded-full backdrop-blur-md border border-yellow-400/30">
          {currentPhase}
        </div>
      </div>

      {/* Contenedor principal con efectos holográficos */}
      <div 
        className="relative w-[1200px] h-[800px] mb-8 rounded-3xl backdrop-blur-md bg-gradient-to-br from-green-900/30 to-black/30 border-2 border-yellow-400/30"
        style={{ 
          perspective: '2000px',
          transformStyle: 'preserve-3d',
          boxShadow: '0 0 80px rgba(255,215,0,0.3), inset 0 0 80px rgba(0,100,0,0.15), 0 0 120px rgba(0,150,255,0.2)'
        }}
      >
        <div
          ref={containerRef}
          className="relative w-full h-full"
          style={{ transformStyle: 'preserve-3d' }}
        >
          {cards.map((id) => {
            const suits = ['♠', '♥', '♦', '♣'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const suit = suits[id % 4];
            const value = values[id % 13];
            const isRed = suit === '♥' || suit === '♦';
            const isFaceCard = ['J', 'Q', 'K', 'A'].includes(value);
            
            return (
              <div
                key={id}
                className="absolute rounded-2xl select-none border-2 border-gray-300 overflow-hidden"
                style={{ 
                  top: '50%',
                  left: '50%',
                  marginTop: '-108px',
                  marginLeft: '-75px',
                  width: '150px',
                  height: '216px',
                  backfaceVisibility: 'hidden',
                  background: `linear-gradient(135deg, 
                    ${isFaceCard ? '#fdfcf0' : '#ffffff'} 0%, 
                    ${isFaceCard ? '#f5f3e7' : '#f8f9fa'} 50%, 
                    ${isFaceCard ? '#fdfcf0' : '#ffffff'} 100%)`,
                  boxShadow: `
                    0 15px 40px rgba(0,0,0,0.2), 
                    0 25px 60px rgba(0,0,0,0.15), 
                    inset 0 3px 0 rgba(255,255,255,0.9),
                    inset 0 -3px 0 rgba(0,0,0,0.08),
                    0 0 20px rgba(255,215,0,0.1)
                  `,
                  border: '2px solid rgba(0,0,0,0.1)'
                }}
              >
                <div className="absolute inset-3 rounded-xl">
                  {/* Esquina superior izquierda */}
                  <div className={`absolute top-3 left-3 text-center ${isRed ? 'text-red-600' : 'text-gray-900'} font-bold`}>
                    <div className="text-xl leading-none font-black">{value}</div>
                    <div className="text-2xl leading-none">{suit}</div>
                  </div>
                  
                  {/* Centro con efectos especiales para cartas de figuras */}
                  <div className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center ${isRed ? 'text-red-600' : 'text-gray-900'}`}>
                    <div className={`${isFaceCard ? 'text-6xl' : 'text-5xl'} ${isFaceCard ? 'animate-pulse' : ''}`}>
                      {suit}
                    </div>
                    {isFaceCard && (
                      <div className="text-sm font-bold mt-1 text-gray-700">
                        {value === 'J' ? 'JACK' : value === 'Q' ? 'QUEEN' : value === 'K' ? 'KING' : 'ACE'}
                      </div>
                    )}
                  </div>
                  
                  {/* Esquina inferior derecha */}
                  <div className={`absolute bottom-3 right-3 text-center transform rotate-180 ${isRed ? 'text-red-600' : 'text-gray-900'} font-bold`}>
                    <div className="text-xl leading-none font-black">{value}</div>
                    <div className="text-2xl leading-none">{suit}</div>
                  </div>
                </div>
                
                {/* Efectos de brillo ultra-mejorados para cartas especiales */}
                {isFaceCard && (
                  <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-yellow-200/30 via-transparent to-purple-200/30 animate-pulse"></div>
                )}
                
                {/* Patrón de fondo holográfico */}
                <div className="absolute inset-0 rounded-2xl opacity-8">
                  <div className={`w-full h-full bg-gradient-to-br ${isRed ? 'from-red-100 to-pink-100' : 'from-blue-100 to-indigo-100'} rounded-2xl`}></div>
                </div>
                
                {/* Efecto de reflejo holográfico */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-tr from-white/10 via-transparent to-transparent opacity-60"></div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Botón ultra-épico */}
      <button
        onClick={ultraRealisticRiffleShuffle}
        disabled={isAnimating}
        className={`relative px-20 py-6 rounded-3xl font-bold text-3xl text-white transition-all duration-700 transform overflow-hidden ${
          isAnimating
            ? 'bg-gray-700 cursor-not-allowed scale-95'
            : 'bg-gradient-to-r from-yellow-600 via-yellow-500 to-yellow-600 hover:from-yellow-500 hover:via-yellow-400 hover:to-yellow-500 hover:scale-115 active:scale-95 shadow-2xl hover:shadow-yellow-500/60'
        }`}
        style={{
          boxShadow: isAnimating 
            ? '0 10px 30px rgba(0,0,0,0.3)' 
            : '0 20px 60px rgba(255,215,0,0.4), 0 0 40px rgba(255,215,0,0.2)'
        }}
      >
        <span className="relative z-10">
          {isAnimating ? '🎴 Ejecutando Shuffle Ultra-Realista...' : '🎴 Iniciar Ultra Riffle Shuffle'}
        </span>
        {!isAnimating && (
          <>
            <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent animate-shimmer"></div>
            <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/20 via-transparent to-yellow-400/20 animate-pulse"></div>
          </>
        )}
      </button>

      {/* Información ultra-épica */}
      <div className="mt-10 text-center text-green-200 text-xl max-w-5xl relative z-10">
        <p className="mb-4 text-3xl font-bold text-yellow-300">
          🎯 <strong>Ultra Riffle Shuffle Hiper-Realista</strong> 🎯
        </p>
        <p className="text-xl opacity-95 mb-3">
          Experiencia visual inmersiva con 20 cartas | Física cuántica | Sistema anti-colisiones | Efectos de sonido visuales
        </p>
        <p className="text-lg opacity-85 mb-2">
          6 Fases Ultra-Avanzadas: Separación de Precisión → Puente Perfecto → Riffle Cuántico → Colapso Gravitacional → Compresión Cuántica → Alineación Holográfica
        </p>
        <p className="text-base opacity-75">
          Incluye: Vibración de cámara • Partículas dinámicas • Física de gravedad • Resistencia del aire • Efectos holográficos
        </p>
      </div>

      <style jsx>{`
        @keyframes shimmer {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        .animate-shimmer {
          animation: shimmer 2.5s ease-in-out infinite;
        }
        .bg-gradient-radial {
          background: radial-gradient(circle, var(--tw-gradient-stops));
        }
        .bg-gradient-conic {
          background: conic-gradient(var(--tw-gradient-stops));
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
      `}</style>
    </div>
  );
}
